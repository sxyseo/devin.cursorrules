# 增强型多智能体协作框架.cursorrules v5.0

## 智能体角色增强协议

### Planner (v5.0)
- 职责：
  - 执行高级分析、任务分解、定义成功标准
  - 评估当前进度和资源分配
  - 制定项目策略和决策
  - 维护任务计划和执行状态
- 行动：
  - 使用高智能模型（SILICONFLOW deepseek-ai/DeepSeek-R1 via `tools/plan_exec_llm.py`）进行规划
  - 维护项目文档和进度跟踪
  - 协调多智能体协作
  - 监控任务执行质量
- 记忆管理：
  - 使用向量记忆系统存储和检索历史决策
  - 维护项目知识图谱
  - 管理文档版本控制
  - 优化知识检索策略
- 错误处理：
  - 超时和错误回退策略
  - 资源冲突解决
  - 依赖关系管理
  - 异常情况预测和预防
- 进度验证：
  - 使用版本快照进行交叉检查
  - 定期进行项目健康检查
  - 维护项目里程碑
  - 质量保证和验证

### Executor (v5.0)
- 职责：
  - 执行Planner指定的具体任务
  - 实现代码和功能
  - 进行测试和验证
  - 提供执行反馈
- 行动：
  - 使用自愈执行引擎处理任务
  - 遵循代码规范和最佳实践
  - 进行代码审查和优化
  - 执行自动化测试
- 错误处理：
  - 环境错误自动修复
  - 语法错误检测和修正
  - 依赖错误解决
  - 测试失败分析
  - 性能问题诊断
- 进度报告：
  - 实时更新任务状态
  - 提供详细执行日志
  - 报告问题和阻塞
  - 性能指标监控

## 记忆管理系统 v6.0

### 记忆银行结构
记忆银行由以下核心文件和可选上下文文件组成，所有文件均使用Markdown格式。文件按照清晰的层次结构构建：

```
memory-bank/
├── projectbrief.md      # 项目简介，定义核心需求和目标
├── productContext.md    # 产品上下文，解释项目存在的原因
├── systemPatterns.md    # 系统模式，描述架构和技术决策
├── techContext.md       # 技术上下文，列出使用的技术
├── activeContext.md     # 活动上下文，当前工作焦点
├── progress.md          # 进度跟踪，记录完成和待完成的工作
└── extensions/          # 扩展目录，存放其他上下文文件
    ├── api_docs.md      # API文档
    ├── integration.md   # 集成规范
    └── testing.md       # 测试策略
```

### 文件更新规则
1. 文件更新的触发条件：
   - 发现新的项目模式时
   - 实施重大更改后
   - 用户明确要求更新记忆银行时（使用"**update memory bank**"指令）
   - 上下文需要澄清时

2. 更新过程必须遵循以下步骤：
   - 查看所有文件
   - 记录当前状态
   - 明确下一步
   - 更新.cursorrules（如有必要）

3. 核心文件职责：
   - `projectbrief.md`：项目基础文档，是所有其他文件的基础
   - `productContext.md`：解释项目目的、解决的问题、运行方式和用户体验目标
   - `activeContext.md`：记录当前工作重点、最近变更、下一步和活动决策
   - `systemPatterns.md`：记录系统架构、关键技术决策、设计模式和组件关系
   - `techContext.md`：记录使用的技术、开发设置、技术约束和依赖关系
   - `progress.md`：跟踪工作进度、待办事项、当前状态和已知问题

### 记忆银行访问协议
在任务开始时，必须读取所有记忆银行文件，这不是可选的。特别注意activeContext.md和progress.md，因为它们跟踪当前状态。

```python
# 使用memory_manager.py脚本访问和更新记忆银行
python tools/memory_manager.py read all  # 读取所有记忆银行文件
python tools/memory_manager.py update activeContext.md  # 更新特定文件
python tools/memory_manager.py create extensions/feature_docs.md  # 创建新的上下文文件
```

### 记忆向量化存储
使用嵌入向量对记忆进行索引，以实现语义搜索：

```python
# 使用memory_index.py脚本管理记忆向量
python tools/memory_index.py index  # 为记忆银行创建向量索引
python tools/memory_index.py search "系统架构设计模式"  # 语义搜索记忆
```

### 三维记忆拓扑
- 短期记忆：
  - 当前会话的即时信息
  - 临时变量和状态
  - 运行时上下文
  - 任务执行状态
- 中期记忆：
  - 模式压缩后的关键信息
  - 项目阶段性成果
  - 重要决策记录
  - 执行策略优化
- 长期记忆：
  - 语义提取后的核心知识
  - 项目最佳实践
  - 经验教训总结
  - 性能优化经验
- 记忆库：
  - 版本化的知识存储
  - 项目文档集合
  - 代码库快照
  - 测试用例库

### 记忆操作规范
1. 自动记忆固化
   ```bash
   # 每30分钟执行增量同步
   python tools/memory_sync.py --interval 30 --compress lz4
   ```
   - 使用LZ4压缩算法
   - 自适应保留策略
   - 版本控制集成
   - 数据一致性检查

2. 语义增强检索
   ```bash
   # 使用BERT嵌入进行语义搜索
   python tools/memory_search.py --query "架构设计" --threshold 0.75 --context-aware
   ```
   - 支持多维度相似度匹配
   - 动态阈值调整
   - 上下文感知查询
   - 相关性排序优化

3. 文档管理
   ```bash
   # 核心文件维护
   python tools/doc_manager.py validate  # 验证文档完整性
   python tools/doc_manager.py version   # 版本控制
   python tools/doc_manager.py track     # 跟踪变更
   python tools/doc_manager.py update-kg # 更新知识图谱
   python tools/doc_manager.py quality   # 质量检查
   ```

## 智能体通信协议 v6

### 结构化消息格式
```json
{
  "message_id": "uuidv5",
  "timestamp": "ISO8601",
  "origin": {
    "role": "Planner|Executor",
    "version": "x.y",
    "context": "task_context",
    "priority": "high|medium|low"
  },
  "destination": "target_role",
  "qos": 1|2|3,
  "payload": {
    "action_type": "task_type",
    "parameters": {},
    "context_hash": "sha3-256",
    "priority": "high|medium|low",
    "deadline": "ISO8601",
    "retry_policy": {
      "max_retries": 3,
      "backoff_factor": 2
    }
  },
  "metadata": {
    "dependencies": [],
    "resources": [],
    "constraints": [],
    "security_level": "high|medium|low"
  }
}
```

### 可靠性保障
- 消息持久化存储
- 指数退避重试策略
- 确认超时机制
- 最大重试次数限制
- 消息优先级管理
- 死锁检测和预防
- 消息完整性验证
- 安全传输加密

## 增强型工具规范

### 智能环境感知
- 五维环境诊断
  - Python环境检查
  - 依赖完整性验证
  - API密钥有效性
  - 磁盘空间监控
  - 内存使用分析
  - 网络连接状态
  - 系统资源使用
- 自动化修复
  - 环境配置修复
  - 依赖冲突解决
  - 资源优化建议
  - 性能调优
  - 安全漏洞修复

### 动态LLM选择矩阵
- 基于任务复杂度的模型选择
  - 低复杂度：Claude-3-5-Sonnet
  - 中等复杂度：GPT-4o
  - 高复杂度：o1-128k
- 模型性能监控
  - 响应时间跟踪
  - 准确率评估
  - 成本优化
  - 资源使用分析
  - 质量指标监控

## 自进化机制

### 实时性能分析
- 智能体健康监控
  - CPU使用率
  - 内存占用
  - 任务准确率
  - 响应延迟
  - 资源利用率
  - 错误率统计
- 资源使用优化
  - 自动扩缩容
  - 负载均衡
  - 缓存策略
  - 并发控制
  - 资源调度

### 策略优化引擎
- 错误模式分析
- 规划器权重调整
- 执行器阈值优化
- 记忆压缩策略
- 自适应学习
- 性能预测
- 资源分配优化

## 智能体协同流程
1. Planner生成任务计划
2. Executor执行任务
3. 实时健康检查
4. 进度更新和验证
5. 策略优化和调整
6. 知识积累和共享
7. 质量保证和验证
8. 性能优化和调优

## 工具集成

### LLM工具
```bash
.venv/bin/python tools/llm_api.py --prompt "prompt" --provider {openai|anthropic|gemini|local|deepseek|azure|siliconflow|openrouter} --model {model_name}
```

### 网页工具
```bash
.venv/bin/python tools/web_scraper.py --max-concurrent 3 URL1 URL2 URL3
```

### 搜索引擎
```bash
.venv/bin/python tools/search_engine.py "search keywords"
```

### 截图验证
```bash
.venv/bin/python tools/screenshot_utils.py URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
.venv/bin/python tools/llm_api.py --prompt "verification question" --provider {openai|anthropic} --image path/to/screenshot.png
```

## 记忆银行工作流程指令
1. 初始化记忆银行：
   ```bash
   python tools/memory_init.py --project-name "项目名称" --description "项目描述"
   ```

2. 在任务开始时读取记忆：
   ```bash
   python tools/memory_read.py --all  # 读取所有文件
   python tools/memory_read.py --file activeContext.md  # 读取特定文件
   ```

3. 更新记忆银行：
   ```bash
   python tools/memory_update.py --file progress.md --content "新的进度信息"
   python tools/memory_update.py --all  # 更新所有需要更新的文件
   ```

4. 记忆搜索：
   ```bash
   python tools/memory_search.py --query "查询内容" --semantic  # 语义搜索
   python tools/memory_search.py --query "精确内容" --exact  # 精确搜索
   ```

5. 记忆备份：
   ```bash
   python tools/memory_backup.py --name "backup_name"  # 创建备份
   python tools/memory_backup.py --restore "backup_name"  # 恢复备份
   ```

## 记忆银行集成

### 核心文件
1. projectbrief.md：项目基础文档
2. productContext.md：产品上下文
3. activeContext.md：当前工作焦点
4. systemPatterns.md：系统架构
5. techContext.md：技术上下文
6. progress.md：进度跟踪
7. quality.md：质量保证
8. performance.md：性能指标

### 工作流程
1. 读取记忆银行文件
2. 验证文件完整性
3. 更新文档
4. 执行任务
5. 记录变更
6. 知识同步
7. 质量验证
8. 性能优化

## 注意事项
1. 任务完成只能由Planner宣布
2. 避免重写整个文档
3. 保留其他角色的记录
4. 记录外部信息请求
5. 重大变更前通知Planner
6. 记录可重用的经验教训
7. 定期进行知识同步
8. 维护文档版本控制
9. 确保代码质量
10. 监控系统性能

# Multi-Agent Scratchpad

## 错误处理与跨平台兼容性增强任务

### 已完成工作
[X] 增强了错误处理系统
- 实现了错误分类、诊断和自动恢复机制
- 开发了错误模式识别系统
- 实现了分层恢复策略

[X] 优化了模拟模式
- 默认启用模拟模式，确保基本功能可用
- 为所有关键工具实现了模拟响应
- 增强了响应内容的真实性和有用性

[X] 开发了系统诊断工具
- 实现了Python环境检查
- 开发了系统资源监控
- 实现了网络连接测试
- 开发了文件系统检查

[X] 实现了跨平台测试框架
- 实现了路径处理测试
- 开发了文件编码测试
- 实现了环境变量测试
- 开发了进程管理测试

[X] 开发了LLM API测试工具
- 实现了提供商测试
- 开发了错误处理测试
- 实现了模拟模式测试

[X] 更新了主程序入口点
- 添加了命令行接口
- 实现了测试和诊断命令
- 增强了服务器启动选项

[X] 更新了项目文档
- 创建了activeContext.md
- 更新了progress.md
- 增强了README.md

### 下一步工作计划
1. 收集多平台测试结果，进一步优化跨平台兼容性
2. 扩展错误模式库，覆盖更多常见错误场景
3. 实现长时间运行的稳定性测试，验证系统的可靠性
4. 开发自适应学习机制，根据历史错误优化恢复策略
5. 增强WebSocket通信的可靠性，实现断线重连和消息重发机制

## 关键实现摘要

### 错误处理系统
- 开发了基于装饰器模式的错误处理机制
- 实现了错误分类系统，支持网络、API、资源等多种类别
- 开发了错误严重性评估机制
- 实现了错误模式库，支持模式匹配和自动恢复
- 添加了详细的错误日志记录和分析功能

### 系统诊断工具
- 实现了全面的Python环境检查
- 开发了系统资源监控，包括CPU、内存、磁盘和网络
- 实现了网络连接测试，支持检测多种服务可用性
- 开发了文件系统检查，支持权限和路径测试
- 实现了环境变量检查和安全显示机制

### 跨平台测试框架
- 开发了平台特定路径处理测试
- 实现了文件编码测试，支持UTF-8、GBK等编码
- 开发了环境变量测试，考虑不同平台的差异
- 实现了进程管理测试，支持进程创建和通信
- 添加了详细的测试报告生成功能

### LLM API测试工具
- 实现了多提供商测试，支持OpenAI、Anthropic等
- 开发了模型特定测试，支持不同模型和参数
- 实现了错误处理测试，验证系统对各种错误情况的处理
- 开发了模拟模式测试，确保模拟响应的有效性
- 添加了性能指标收集和分析功能

## 用户指定的经验教训

- 你有一个python venv在./venv中。始终在进行Python开发时使用（激活）它。首先，检查'uv'是否可用，使用`which uv`。如果是这种情况，先激活venv，然后使用`uv pip install`安装包。否则，回退到`pip`。
- 在程序输出中包含有助于调试的信息。
- 在尝试编辑文件之前先阅读文件内容。
- 由于Cursor的限制，当使用`git`和`gh`并需要提交多行提交消息时，首先将消息写入文件中，然后使用`git commit -F <filename>`或类似命令提交。之后删除该文件。在提交消息和PR标题中包含"[Cursor] "。

## Cursor学到的经验教训

- 对于搜索结果，确保正确处理不同的字符编码（UTF-8）以支持国际查询
- 在stderr中添加调试信息，同时保持stdout的主要输出清晰，以便更好地进行管道集成
- 当使用seaborn样式在matplotlib中时，由于最近seaborn版本的变化，使用'seaborn-v0_8'而不是'seaborn'作为样式名称
- 使用'gpt-4o'作为OpenAI的GPT-4具有视觉能力的模型名称
- 当搜索最新新闻时，使用当前年份（2025）而不是之前的年份，或者简单地使用"recent"关键字获取最新信息

### 错误处理最佳实践

- **错误分类系统**：将错误按类别（网络、API、资源等）和严重程度进行分类，有助于实施针对性的恢复策略
- **分层恢复策略**：为不同类型的错误设计特定的恢复策略，从轻量级到重量级递进
- **指数退避重试**：对网络和API错误实施指数退避重试，避免立即重试导致更多失败
- **装饰器模式**：使用装饰器方式实现错误处理，降低对现有代码的侵入性
- **错误模式识别**：建立错误模式库，通过模式匹配识别常见错误并自动应用相应恢复策略
- **动态提供商切换**：在主要服务提供商失败时，实现自动切换到备用提供商的机制
- **全面日志记录**：记录错误上下文、系统信息和恢复尝试，便于后期分析和改进

### 跨平台兼容性经验

- 使用`platform.system()`检测操作系统，针对不同平台采用特定策略
- 路径处理统一使用`pathlib.Path`，避免不同平台路径分隔符问题
- 避免直接使用特定于平台的命令和工具
- 在Windows环境中，特别注意文件锁定和权限问题
- 日志文件路径应考虑不同平台的用户主目录位置差异
- Windows长路径支持需要特殊处理，使用`\\?\`前缀或启用长路径支持
- 使用跨平台的临时文件处理方式，如`tempfile`模块
- 文件系统权限和锁定机制在不同平台有显著差异，需要针对性处理

### LLM集成优化经验

- 使用统一的错误处理装饰器包装所有LLM调用函数
- 实现模拟(mock)模式，在开发和测试过程中不依赖实际API
- 为不同的LLM提供商实现适配器，统一接口但处理各自特殊性
- 使用线程池管理并发LLM请求，避免资源耗尽
- 实现请求节流和速率限制，避免触发API提供商的限制
- 缓存常见查询结果，减少重复API调用

### WebSocket通信最佳实践

- **心跳机制**：实现定期心跳消息，及时检测连接断开
- **优雅重连**：实现自动重连机制，包括指数退避策略
- **消息确认**：对重要消息实现确认机制，确保送达
- **消息序列化**：统一使用JSON进行消息序列化，处理好UTF-8编码
- **状态管理**：维护连接状态机，处理各种状态转换
- **资源清理**：在断开连接时确保所有资源正确释放
- **超时控制**：为所有关键操作设置合理的超时时间
- **错误分类**：区分网络错误、协议错误和业务错误
- **会话恢复**：支持在重连后恢复会话状态
- **流量控制**：实现消息流量控制，避免拥塞

### 跨平台客户端实现策略

- **统一API设计**：设计与平台无关的一致API接口
- **平台特定适配层**：将平台特定代码隔离在适配层中
- **抽象文件操作**：使用抽象文件操作接口，避免直接使用系统API
- **环境变量管理**：实现统一的环境变量访问方法
- **日志策略**：针对不同平台使用适当的日志位置和格式
- **测试覆盖**：为每个平台维护特定的测试用例和持续集成
- **版本兼容性**：清晰定义不同平台的最低支持版本
- **依赖管理**：使用虚拟环境和依赖锁定文件
- **编码处理**：统一使用UTF-8编码，处理好不同平台的默认编码
# 增强型多智能体协作框架.cursorrules v5.0

## 智能体角色增强协议

### Planner (v5.0)
- 职责：
  - 执行高级分析、任务分解、定义成功标准
  - 评估当前进度和资源分配
  - 制定项目策略和决策
  - 维护任务计划和执行状态
- 行动：
  - 使用高智能模型（SILICONFLOW deepseek-ai/DeepSeek-R1 via `tools/plan_exec_llm.py`）进行规划
  - 维护项目文档和进度跟踪
  - 协调多智能体协作
  - 监控任务执行质量
- 记忆管理：
  - 使用向量记忆系统存储和检索历史决策
  - 维护项目知识图谱
  - 管理文档版本控制
  - 优化知识检索策略
- 错误处理：
  - 超时和错误回退策略
  - 资源冲突解决
  - 依赖关系管理
  - 异常情况预测和预防
- 进度验证：
  - 使用版本快照进行交叉检查
  - 定期进行项目健康检查
  - 维护项目里程碑
  - 质量保证和验证

### Executor (v5.0)
- 职责：
  - 执行Planner指定的具体任务
  - 实现代码和功能
  - 进行测试和验证
  - 提供执行反馈
- 行动：
  - 使用自愈执行引擎处理任务
  - 遵循代码规范和最佳实践
  - 进行代码审查和优化
  - 执行自动化测试
- 错误处理：
  - 环境错误自动修复
  - 语法错误检测和修正
  - 依赖错误解决
  - 测试失败分析
  - 性能问题诊断
- 进度报告：
  - 实时更新任务状态
  - 提供详细执行日志
  - 报告问题和阻塞
  - 性能指标监控

## 记忆管理系统 v6.0

### 记忆银行结构
记忆银行由以下核心文件和可选上下文文件组成，所有文件均使用Markdown格式。文件按照清晰的层次结构构建：

```
memory-bank/
├── projectbrief.md      # 项目简介，定义核心需求和目标
├── productContext.md    # 产品上下文，解释项目存在的原因
├── systemPatterns.md    # 系统模式，描述架构和技术决策
├── techContext.md       # 技术上下文，列出使用的技术
├── activeContext.md     # 活动上下文，当前工作焦点
├── progress.md          # 进度跟踪，记录完成和待完成的工作
└── extensions/          # 扩展目录，存放其他上下文文件
    ├── api_docs.md      # API文档
    ├── integration.md   # 集成规范
    └── testing.md       # 测试策略
```

### 文件更新规则
1. 文件更新的触发条件：
   - 发现新的项目模式时
   - 实施重大更改后
   - 用户明确要求更新记忆银行时（使用"**update memory bank**"指令）
   - 上下文需要澄清时

2. 更新过程必须遵循以下步骤：
   - 查看所有文件
   - 记录当前状态
   - 明确下一步
   - 更新.cursorrules（如有必要）

3. 核心文件职责：
   - `projectbrief.md`：项目基础文档，是所有其他文件的基础
   - `productContext.md`：解释项目目的、解决的问题、运行方式和用户体验目标
   - `activeContext.md`：记录当前工作重点、最近变更、下一步和活动决策
   - `systemPatterns.md`：记录系统架构、关键技术决策、设计模式和组件关系
   - `techContext.md`：记录使用的技术、开发设置、技术约束和依赖关系
   - `progress.md`：跟踪工作进度、待办事项、当前状态和已知问题

### 记忆银行访问协议
在任务开始时，必须读取所有记忆银行文件，这不是可选的。特别注意activeContext.md和progress.md，因为它们跟踪当前状态。

```python
# 使用memory_manager.py脚本访问和更新记忆银行
python tools/memory_manager.py read all  # 读取所有记忆银行文件
python tools/memory_manager.py update activeContext.md  # 更新特定文件
python tools/memory_manager.py create extensions/feature_docs.md  # 创建新的上下文文件
```

### 记忆向量化存储
使用嵌入向量对记忆进行索引，以实现语义搜索：

```python
# 使用memory_index.py脚本管理记忆向量
python tools/memory_index.py index  # 为记忆银行创建向量索引
python tools/memory_index.py search "系统架构设计模式"  # 语义搜索记忆
```

### 三维记忆拓扑
- 短期记忆：
  - 当前会话的即时信息
  - 临时变量和状态
  - 运行时上下文
  - 任务执行状态
- 中期记忆：
  - 模式压缩后的关键信息
  - 项目阶段性成果
  - 重要决策记录
  - 执行策略优化
- 长期记忆：
  - 语义提取后的核心知识
  - 项目最佳实践
  - 经验教训总结
  - 性能优化经验
- 记忆库：
  - 版本化的知识存储
  - 项目文档集合
  - 代码库快照
  - 测试用例库

### 记忆操作规范
1. 自动记忆固化
   ```bash
   # 每30分钟执行增量同步
   python tools/memory_sync.py --interval 30 --compress lz4
   ```
   - 使用LZ4压缩算法
   - 自适应保留策略
   - 版本控制集成
   - 数据一致性检查

2. 语义增强检索
   ```bash
   # 使用BERT嵌入进行语义搜索
   python tools/memory_search.py --query "架构设计" --threshold 0.75 --context-aware
   ```
   - 支持多维度相似度匹配
   - 动态阈值调整
   - 上下文感知查询
   - 相关性排序优化

3. 文档管理
   ```bash
   # 核心文件维护
   python tools/doc_manager.py validate  # 验证文档完整性
   python tools/doc_manager.py version   # 版本控制
   python tools/doc_manager.py track     # 跟踪变更
   python tools/doc_manager.py update-kg # 更新知识图谱
   python tools/doc_manager.py quality   # 质量检查
   ```

## 智能体通信协议 v6

### 结构化消息格式
```json
{
  "message_id": "uuidv5",
  "timestamp": "ISO8601",
  "origin": {
    "role": "Planner|Executor",
    "version": "x.y",
    "context": "task_context",
    "priority": "high|medium|low"
  },
  "destination": "target_role",
  "qos": 1|2|3,
  "payload": {
    "action_type": "task_type",
    "parameters": {},
    "context_hash": "sha3-256",
    "priority": "high|medium|low",
    "deadline": "ISO8601",
    "retry_policy": {
      "max_retries": 3,
      "backoff_factor": 2
    }
  },
  "metadata": {
    "dependencies": [],
    "resources": [],
    "constraints": [],
    "security_level": "high|medium|low"
  }
}
```

### 可靠性保障
- 消息持久化存储
- 指数退避重试策略
- 确认超时机制
- 最大重试次数限制
- 消息优先级管理
- 死锁检测和预防
- 消息完整性验证
- 安全传输加密

## 增强型工具规范

### 智能环境感知
- 五维环境诊断
  - Python环境检查
  - 依赖完整性验证
  - API密钥有效性
  - 磁盘空间监控
  - 内存使用分析
  - 网络连接状态
  - 系统资源使用
- 自动化修复
  - 环境配置修复
  - 依赖冲突解决
  - 资源优化建议
  - 性能调优
  - 安全漏洞修复

### 动态LLM选择矩阵
- 基于任务复杂度的模型选择
  - 低复杂度：Claude-3-5-Sonnet
  - 中等复杂度：GPT-4o
  - 高复杂度：o1-128k
- 模型性能监控
  - 响应时间跟踪
  - 准确率评估
  - 成本优化
  - 资源使用分析
  - 质量指标监控

## 自进化机制

### 实时性能分析
- 智能体健康监控
  - CPU使用率
  - 内存占用
  - 任务准确率
  - 响应延迟
  - 资源利用率
  - 错误率统计
- 资源使用优化
  - 自动扩缩容
  - 负载均衡
  - 缓存策略
  - 并发控制
  - 资源调度

### 策略优化引擎
- 错误模式分析
- 规划器权重调整
- 执行器阈值优化
- 记忆压缩策略
- 自适应学习
- 性能预测
- 资源分配优化

## 智能体协同流程
1. Planner生成任务计划
2. Executor执行任务
3. 实时健康检查
4. 进度更新和验证
5. 策略优化和调整
6. 知识积累和共享
7. 质量保证和验证
8. 性能优化和调优

## 工具集成

### LLM工具
```bash
.venv/bin/python tools/llm_api.py --prompt "prompt" --provider {openai|anthropic|gemini|local|deepseek|azure|siliconflow|openrouter} --model {model_name}
```

### 网页工具
```bash
.venv/bin/python tools/web_scraper.py --max-concurrent 3 URL1 URL2 URL3
```

### 搜索引擎
```bash
.venv/bin/python tools/search_engine.py "search keywords"
```

### 截图验证
```bash
.venv/bin/python tools/screenshot_utils.py URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
.venv/bin/python tools/llm_api.py --prompt "verification question" --provider {openai|anthropic} --image path/to/screenshot.png
```

## 记忆银行工作流程指令
1. 初始化记忆银行：
   ```bash
   python tools/memory_init.py --project-name "项目名称" --description "项目描述"
   ```

2. 在任务开始时读取记忆：
   ```bash
   python tools/memory_read.py --all  # 读取所有文件
   python tools/memory_read.py --file activeContext.md  # 读取特定文件
   ```

3. 更新记忆银行：
   ```bash
   python tools/memory_update.py --file progress.md --content "新的进度信息"
   python tools/memory_update.py --all  # 更新所有需要更新的文件
   ```

4. 记忆搜索：
   ```bash
   python tools/memory_search.py --query "查询内容" --semantic  # 语义搜索
   python tools/memory_search.py --query "精确内容" --exact  # 精确搜索
   ```

5. 记忆备份：
   ```bash
   python tools/memory_backup.py --name "backup_name"  # 创建备份
   python tools/memory_backup.py --restore "backup_name"  # 恢复备份
   ```

## 记忆银行集成

### 核心文件
1. projectbrief.md：项目基础文档
2. productContext.md：产品上下文
3. activeContext.md：当前工作焦点
4. systemPatterns.md：系统架构
5. techContext.md：技术上下文
6. progress.md：进度跟踪
7. quality.md：质量保证
8. performance.md：性能指标

### 工作流程
1. 读取记忆银行文件
2. 验证文件完整性
3. 更新文档
4. 执行任务
5. 记录变更
6. 知识同步
7. 质量验证
8. 性能优化

## 注意事项
1. 任务完成只能由Planner宣布
2. 避免重写整个文档
3. 保留其他角色的记录
4. 记录外部信息请求
5. 重大变更前通知Planner
6. 记录可重用的经验教训
7. 定期进行知识同步
8. 维护文档版本控制
9. 确保代码质量
10. 监控系统性能

# Multi-Agent Scratchpad

## 任务规划优化功能开发总结

### 已完成功能
[X] `_analyze_task`方法的实现，支持任务分析和子任务创建
[X] `StrategicEngine.decompose_goal`方法优化，增强任务分解智能性
[X] 创建`plan_exec_llm.py`模块，支持多种LLM提供商集成
[X] 实现模拟响应机制，在LLM不可用时提供基本功能
[X] 优化任务关键词检测，针对不同任务类型提供定制化分解

### 关键实现
1. **任务分析系统**：实现了能够利用LLM进行任务分解的`_analyze_task`方法，解析任务描述并创建子任务
2. **LLM集成**：支持多种LLM提供商，包括OpenAI、Anthropic、SiliconFlow等，提供统一的接口
3. **错误处理**：实现了完善的错误处理和重试机制，确保LLM调用的可靠性
4. **智能响应**：在LLM不可用时，系统能够根据关键词分析提供合理的模拟响应
5. **优化的提示词设计**：为任务分解设计了结构化的提示词，引导LLM生成高质量的任务分解结果

### 下一步工作计划
1. 增强任务调度算法，考虑依赖关系和资源约束
2. 实现动态优先级计算，优化任务执行顺序
3. 开发任务执行监控和动态调整机制
4. 增强与记忆系统的集成，利用历史数据优化规划
5. 实现复杂依赖关系的分析和关键路径识别

### 系统集成情况
- 任务规划功能已与`Planner`类成功集成
- LLM调用模块可独立使用，也可集成到其他组件
- 确保了代码的模块化和可测试性，方便未来扩展
- 通过命令行接口提供任务分解功能，方便测试和调试

任务规划优化功能的开发标志着多智能体协作框架核心能力的一大进步，通过智能的任务分解和规划，系统能够更高效地处理复杂任务，提升整体的工作效率和质量。

# Multi-Agent Scratchpad

## Background and Motivation
增强型多智能体协作框架旨在解决AI系统在复杂任务中的记忆保持和检索困难、多智能体协作不畅以及错误处理能力不足等问题。通过建立基于Planner-Executor模式的智能体系统，实现高效任务规划和执行。

## Key Challenges and Analysis
- 记忆管理系统设计：需要兼顾记忆检索效率与存储空间
- 智能体通信可靠性：确保消息传递的稳定性和准确性
- 跨平台兼容性：需支持Windows、macOS和Linux系统
- 状态持久化：实现智能体状态的有效保存和恢复

## Verifiable Success Criteria
- 记忆检索延迟<100ms
- 通信系统可靠性>99.9%
- 复杂任务规划准确率>95%
- 错误自动恢复率>90%
- 支持多种LLM提供商集成

## High-level Task Breakdown
1. 记忆管理系统开发
2. 智能体角色实现
3. 通信协议开发
4. 工具集成
5. 测试与优化

## Current Status / Progress Tracking
- 记忆管理系统：100% 完成
- 智能体角色实现：100% 完成
- 通信协议开发：100% 完成
- 工具集成：60% 完成
- 测试与优化：40% 完成

## Next Steps and Action Items
1. 开发复杂场景测试套件
2. 优化任务分解算法
3. 实现高级错误处理机制
4. 开发性能监控系统
5. 实现动态LLM选择矩阵

## Executor's Feedback or Assistance Requests
- 已解决所有关键功能开发问题
- 系统稳定性测试需要加强，建议设计长时间运行的压力测试

# 记忆银行使用指南

## 记忆库更新流程
1. 使用"**update memory bank**"触发完整更新
2. 确保读取所有文件，特别是activeContext.md和progress.md
3. 遵循以下更新标准：
   - 保留原始结构
   - 只更新需要变更的部分
   - 添加时间戳和版本标记
   - 确保文件之间的一致性

## 记忆库访问模式
- 任务启动时：读取所有记忆库文件
- 工作过程中：根据需要访问相关文件
- 任务完成时：更新进度文件和活动上下文

## 记忆库与Scratchpad集成
- 使用Scratchpad进行临时计划和状态跟踪
- 记忆库存储长期知识和经验
- 定期将Scratchpad中的关键信息迁移到记忆库

## 遵循的核心原则
- 所有重要决策必须记录在记忆库中
- 记忆库是唯一的真实来源
- 保持记忆库的简洁和组织
- 定期更新和同步记忆库

## 任务完成情况

已完成的工作:
- 修复了`llm_api.py`中的相对导入错误，增强了跨平台兼容性
- 实现了模拟(mock)模式，提供在LLM服务不可用时的可靠后备方案
- 开发了全面的错误处理模块`error_handler.py`，支持错误分类、诊断和自动恢复
- 整合错误处理模块到LLM API，增强系统可靠性
- 更新了记忆库文件，记录最新进展

## 下一步工作

1. 将错误处理模块整合到`plan_exec_llm.py`中
2. 开发错误模式识别系统，提高自动恢复成功率
3. 实现更全面的跨平台测试

# Lessons

## 用户指定的经验教训

- 你有一个python venv在./venv中。始终在进行Python开发时使用（激活）它。首先，检查'uv'是否可用，使用`which uv`。如果是这种情况，先激活venv，然后使用`uv pip install`安装包。否则，回退到`pip`。
- 在程序输出中包含有助于调试的信息。
- 在尝试编辑文件之前先阅读文件内容。
- 由于Cursor的限制，当使用`git`和`gh`并需要提交多行提交消息时，首先将消息写入文件中，然后使用`git commit -F <filename>`或类似命令提交。之后删除该文件。在提交消息和PR标题中包含"[Cursor] "。

## Cursor学到的经验教训

- 对于搜索结果，确保正确处理不同的字符编码（UTF-8）以支持国际查询
- 在stderr中添加调试信息，同时保持stdout的主要输出清晰，以便更好地进行管道集成
- 当使用seaborn样式在matplotlib中时，由于最近seaborn版本的变化，使用'seaborn-v0_8'而不是'seaborn'作为样式名称
- 使用'gpt-4o'作为OpenAI的GPT-4具有视觉能力的模型名称
- 当搜索最新新闻时，使用当前年份（2025）而不是之前的年份，或者简单地使用"recent"关键字获取最新信息

### 错误处理最佳实践

- **错误分类系统**：将错误按类别（网络、API、资源等）和严重程度进行分类，有助于实施针对性的恢复策略
- **分层恢复策略**：为不同类型的错误设计特定的恢复策略，从轻量级到重量级递进
- **指数退避重试**：对网络和API错误实施指数退避重试，避免立即重试导致更多失败
- **装饰器模式**：使用装饰器方式实现错误处理，降低对现有代码的侵入性
- **错误模式识别**：建立错误模式库，通过模式匹配识别常见错误并自动应用相应恢复策略
- **动态提供商切换**：在主要服务提供商失败时，实现自动切换到备用提供商的机制
- **全面日志记录**：记录错误上下文、系统信息和恢复尝试，便于后期分析和改进

### 跨平台兼容性经验

- 使用`platform.system()`检测操作系统，针对不同平台采用特定策略
- 路径处理统一使用`pathlib.Path`，避免不同平台路径分隔符问题
- 避免直接使用特定于平台的命令和工具
- 在Windows环境中，特别注意文件锁定和权限问题
- 日志文件路径应考虑不同平台的用户主目录位置差异
- Windows长路径支持需要特殊处理，使用`\\?\`前缀或启用长路径支持
- 使用跨平台的临时文件处理方式，如`tempfile`模块
- 文件系统权限和锁定机制在不同平台有显著差异，需要针对性处理

### LLM集成优化经验

- 使用统一的错误处理装饰器包装所有LLM调用函数
- 实现模拟(mock)模式，在开发和测试过程中不依赖实际API
- 为不同的LLM提供商实现适配器，统一接口但处理各自特殊性
- 使用线程池管理并发LLM请求，避免资源耗尽
- 实现请求节流和速率限制，避免触发API提供商的限制
- 缓存常见查询结果，减少重复API调用

### WebSocket通信最佳实践

- **心跳机制**：实现定期心跳消息，及时检测连接断开
- **优雅重连**：实现自动重连机制，包括指数退避策略
- **消息确认**：对重要消息实现确认机制，确保送达
- **消息序列化**：统一使用JSON进行消息序列化，处理好UTF-8编码
- **状态管理**：维护连接状态机，处理各种状态转换
- **资源清理**：在断开连接时确保所有资源正确释放
- **超时控制**：为所有关键操作设置合理的超时时间
- **错误分类**：区分网络错误、协议错误和业务错误
- **会话恢复**：支持在重连后恢复会话状态
- **流量控制**：实现消息流量控制，避免拥塞

### 跨平台客户端实现策略

- **统一API设计**：设计与平台无关的一致API接口
- **平台特定适配层**：将平台特定代码隔离在适配层中
- **抽象文件操作**：使用抽象文件操作接口，避免直接使用系统API
- **环境变量管理**：实现统一的环境变量访问方法
- **日志策略**：针对不同平台使用适当的日志位置和格式
- **测试覆盖**：为每个平台维护特定的测试用例和持续集成
- **版本兼容性**：清晰定义不同平台的最低支持版本
- **依赖管理**：使用虚拟环境和依赖锁定文件
- **编码处理**：统一使用UTF-8编码，处理好不同平台的默认编码
- **性能考量**：针对不同平台的性能特点进行优化

# Scratchpad

## 当前任务：增强错误处理和跨平台测试

### 任务分解

[X] 将错误处理模块整合到`plan_exec_llm.py`中
[X] 开发错误模式识别系统，提高自动恢复成功率
[X] 实现更全面的跨平台测试
[X] 创建`test_cross_platform.py`测试脚本
[X] 更新项目文档记录进展

### 已完成工作

1. 已修复`llm_api.py`中的导入错误问题
   - 使用绝对导入替换相对导入
   - 添加sys.path处理确保模块可见性
   - 实现了Mock模式提供测试环境

2. 已将错误处理整合到`plan_exec_llm.py`
   - 添加了错误处理装饰器
   - 实现了错误分类和严重程度评估
   - 开发了针对性的恢复策略
   - 添加了LLM提供商自动切换功能

3. 已开发错误模式识别系统
   - 创建了错误模式库
   - 实现了模式匹配算法
   - 开发了自动恢复触发器
   - 添加了恢复效果评估机制

4. 已创建跨平台测试框架
   - 实现了系统检测和平台适配
   - 添加了文件路径处理测试
   - 实现了环境变量测试
   - 开发了LLM调用兼容性测试

5. 已更新项目文档
   - 更新了activeContext.md
   - 更新了progress.md
   - 更新了.cursorrules

### 下一步工作

1. 扩展错误模式库，覆盖更多常见错误场景
2. 开发长时间稳定性测试，验证系统在持续运行中的可靠性
3. 在多平台上执行完整功能测试
4. 优化系统性能，特别是在错误恢复过程中的响应时间
5. 开发基于历史错误的自适应学习机制